<!-- omit in toc -->
# 13. 自由モノイド

モノイドは、圏論とプログラミングにおいて重要な概念です。圏は強い型付き言語に対応し、モノイドは動的型付き言語に対応します。モノイドにおいて任意の2つの射を合成できますが、これは動的型付き言語において任意の2つの関数を合成できることに対応します (もちろん、実行時エラーが出るかもしれません)。

第3章において、モノイドは、対象がたった1つで、全てのロジックは射の合成規則になっているような圏であると説明しました。この圏論的モデルは、集合の2つの要素を「操作する」と3つ目の要素が得られるという、より伝統的な集合論的なモノイドの定義と等しいです。さらに、この「操作」のプロセスは、2つのプロセスに分解されます。まず要素のペアを形成し、次に、このペアをある要素 (要素の積) に一意に紐付けます。

操作の2番目の部分 - ペアとある要素の一意の紐付け - がないと、何が起こるでしょうか？例えば、任意の集合を考え、考えうるすべてのペアを形成し、それらを集合の新しい要素とすることにしましょう。すると、これらの新しい要素とのペアを考えることができます。これは連鎖反応であり、無限に新しい要素を追加し続けられます。結果として、有限集合は**ほとんど**モノイドになります。モノイドはまた、単位元と結合律を必要とします。これに関しては問題はなく、特別な単位元と、いくつかのペアの一意の紐付けを追加することができ、それによって単位元と結合律がサポートされます。

では、どのように機能するか、簡単な例で見てみましょう。2つの要素からなる集合 $$ \{a, b\} $$ から始めましょう。自由モノイドの生成器と呼ぶことになるでしょう。まず、単位元として提供される特別な要素 $$ e $$ を追加します。次に、全ての要素のペアを追加し、それらを積と呼びます。 $$ a $$ と $$ b $$ との積はペア $$ (a, b) $$ になるでしょう。 $$ b $$ と $$ a $$ の積はペア $$ (b, a) $$ になり、 $$ a $$ と $$ a $$ の積は $$ (a, a) $$ になり、 $$ b $$ と $$ b $$ の積は $$ (b, b) $$ になります。また、 $$ e $$ との積、すなわち $$ (a, e) $$, $$ (e, b) $$ などを追加することができますが、それらを $$ a $$, $$ b $$ などに対応させることにします。したがって、この段階で追加された要素は $$ (a, a), (a, b), (b, a), (b, b) $$ であって、得られる集合は $$ \{e, a, b, (a, a), (a, b), (b, a), (b, b) \} $$ となります。

次の段階でも、 $$ (a, (a, b)) $$ や $$ ((a, b), a) $$ など、新たにペアを追加していきます。このとき、ペアが結合律を満たすようにしなければいけません。すなわち、 $$ (a, (b, a)) $$ を $$ ((a, b), a) $$ に対応させますし、他のペアについても同様です。言い換えれば、ペア内のカッコの必要性はありません。

このプロセスの最終的な結果として、 $$ a $$ と $$ b $$ の全ての可能なリストを作成することになるでしょう。実際、 $$ e $$ を空リストとして表現すれば、「操作」は単にリストの連結と見ることができます。

要素の全ての可能な組み合わせを生成し続けるこの種の構造は、一意の対応付けを最低限に行います。単に単位元の存在と結合律を保証するだけです。このような構造は、自由構造と呼ばれます。今ここで構築したものは、 生成器の集合 $$ \{ a, b \} $$ に関する**自由モノイド** (free monoid) です。

## 13.1 Scala における自由モノイド

Scala において、2要素集合は `Boolean` 型に対応し、この集合によって生成される自由モノイドは `List[Boolean]` 型に対応します。（無限リストに関する問題はあえて無視しています。）

Scala におけるモノイドは、型クラスによって次のように定義されます:

```scala
trait Monoid[M] {

  /** Unit element of binary operation */
  def empty: M

  /** Binary operation which must be associative */
  def combine(m1: M, m2: M): M
}
```

この定義は、全ての `Monoid` が `empty` と呼ばれる単位元を持ち、そして `combine` と呼ばれる二項関数を持たなければいけない、と述べているだけである。Scala において単位律と結合律は示されておらず、モノイドのインスタンスを実装するときにプログラマーが検証しなければいけない。

任意の型のリストがモノイドを形成するという事実は、このインスタンス定義によって説明されます：

```scala
implicit def listMonoid[A]: Monoid[List[A]] =
  new Monoid[List[A]] {
    def combine(a: List[A], b: List[A]): List[A] = a ++ b
    def empty: List[A] = Nil
  }
```

この定義は、空リスト `Nil` が単位元であること、リストの連結 `++` が二項演算であることを示しています。

見てきたとおり、型 `A` のリストは集合 $$ A $$ に関する自由モノイドに対応します。なお、乗算を持つ自然数の集合は自由モノイドではありません。例えば、2 と 3 から乗算によって計算されるのは 6 ですが、2 と 3 の組み合わせによって生成されるのは (2, 3) であって、6 ではありません。

```scala
2 * 3 == 6
List(2) ++ List(3) == List(2, 3) // List(6) ではない
```

これは簡単でしたが、気になるのは、中身の対象を気にしなくても、圏論においてこの自由構造を作ることができるのか、というところです。またもや、普遍構造を使います。

2つ目の興味深い問いは、いくつかの自由モノイドから、法則に課せられる最小限の要素を式別することによって、任意のモノイドを得ることができるのか、です。これは普遍構造から直接導かれることを示します。

## 13.2 自由モノイドの普遍的構造

これまで普遍的構造を導いたプロセスを思い出してみると、何かを構築することは与えられたパターンに一番合致する対象を選ぶことなのではと気づくかもしれません。したがって、自由モノイドを構築するために普遍的構造を使いたいのであれば、1つを選択するために非常にたくさんのモノイドを考えなければなりません。選択するためには、モノイドの圏全体が必要です。しかし、モノイドは圏を形成するのでしょうか？

まずは、単位元と二項演算によって定義される追加の構造を備えた、集合としてのモノイドを見ていきましょう。モノイドの構造を保存するような関数を射に選びます。このような構造を保存する関数は**準同型写像** (homomorphism) と呼ばれます。モノイド準同型写像は、2つの要素の積を2つの要素の像の積に対応させます:

```scala
h (a * b) == h(a) * h(b)
```

そして、単位元を単位元に対応させます。

and it must map unit to unit.

例として、整数のリストから整数への準同型写像を考えます。`List(2)` を `2` に対応させ `List(3)` を `3` に対応させるのなら、`List(2, 3)` を `6` に対応させなければいけません。なぜなら、リストの連結

```scala
List(2) ++ List(3) == List(2, 3)
```

は乗算になるからです。

```scala
2 * 3 == 6
```

今、個々のモノイドの内部構造については忘れて、モノイドを対象として、その間の射についてのみ考えてみましょう。モノイドの圏 $$ \mathbb{Mon} $$ があるとします。

内部構造を忘れる前に、重要な性質について述べておきましょう。 $$ Mon $$ の全ての対象は、自明に集合へと対応します。それはただ、その要素の集合です。この集合は台集合 (underlying set) と呼ばれます。実は、 $$ Mon $$ の対象を集合に対応できるだけでなく、 $$ Mon $$ の射 (モノイド準同型写像) を関数に対応できます。これは当たり前のことに思えますが、すぐに役に立ちます。この $$ Mon $$ から $$ Set $$ への対象と射の対応は、実は関手なのです。この関手はモノイドの構造を「忘れる」ので (ただの集合の中に入ると、単位元を区別したり二項演算を気にしなくなります)、**忘却関手** (forgetful functor) と呼ばれます。忘却関手は、圏論においてよく出てきます。

いま、 $$ Mon $$ に関する2つの異なる見方があります。この圏を、対象と射を持つ任意の他の圏と全く同じように扱うことができます。その観点では、モノイドの内部構造を見ていません。 $$ Mon $$ の特定の対象に関してただ言えることは、射を通じてそれ自身あるいは他の対象に繋がることです。射の二項演算表 (合成規則) は、もう一つの観点である集合としてのモノイドから導かれます。圏論にいくことによってこの観点を完全に無くしていました。しかし、忘却関手によってもう一度この観点にアクセスできるようになります。

普遍的構造を適用するために、
