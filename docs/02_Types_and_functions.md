# 2. 型と関数

型と関数からなる圏は、プログラミングにおいて重要な役割を果たします。ここでは、型とは何か、なぜ型が必要なのかについて話しましょう。

## 2.1 誰が型を必要とするか

型付けには、静的な型付けと動的な型付けがあります。静的型付けは、変数や関数の引数、返り値などの型がコンパイル時のような実行前に定められるシステムです。一方で、動的型付けは、実行時の実際の値によって型が定められるシステムです。

動的型付け言語では、型のミスマッチは実行時に発見されます。一方で、静的型付け言語では型のミスマッチはコンパイル時に発見され、実行前にプログラムが文法的に正しいかどうかチェックすることができます。

Scala や Haskell、C++ のような言語は静的型付け言語です。静的型付け言語を採用することによって、文法エラーや型ミスマッチに対応しやすくなります。

## 2.2 型は合成可能性を表す

TODO

## 2.3 型とは何か

最も直感的な型の解釈は、型が値の集合であることです。例えば、型 `Boolean` は値 `true` と `false` の集合です。型 `Char` はすべての Unicode の文字の集合です。

型を集合として解釈すると、`x` が `Int` 型であることを宣言するとき

```scala
val x: Int
```

と書き、 `x` は整数集合の要素であると言います。

しかし、型を集合として解釈するには微妙な点が少々あります。一般に、集合全体の集合を定義することはできません (Tips 参照)。そのため、循環定義を含む多相関数 (polymorphic function) を集合で表すことは難しくなります。

そこで、代わりに集合の圏 `Set` を用いて型を表現します。 `Set`  は、集合を対象とし、関数を射とする圏です。

TODO

---
### Tips
集合全体の集合を定義できるとすると、ラッセル (Russell) のパラドックスという現象が生じます。

ラッセルのパラドックスでは「自分自身を持たない集合全体の集合」を考えます。そのような集合を `A` と置くことにしましょう。このとき、 `A` は `A` 自身を要素として持つでしょうか？

場合分けして考えてみます。

1. `A` が `A` 自身を要素として持つ場合：`A` の定義より、 `A` は自分自身を持たない集合です。一方で、`A` は `A` 自身を持っています。これは矛盾です。
2. `A` が `A` 自身を要素として持たない場合：`A` は `A` 自身を要素として持たないので、 `A` は `A` の要素です。これは矛盾です。

以上の通り、「自分自身を持たない集合全体の集合」というものを考えると矛盾が生じてしまいます。

循環定義の罠ですね。そのような集合は集合とみなさないようにルールを定めた公理的集合論というものが、今の集合論の主流になっています。

---


## 2.4 数学的モデルがなぜ必要なのか

言語の意味論 (セマンティクス) を表現する正式な方法はありますが、その複雑性のため、主にプログラミングの用語ではなく、簡単化された学術言語とともに使われます。例えば、**操作的意味論** (operational semantics) と呼ばれるツールは、プログラム実行のメカニズムを表現します。操作的意味論は形式化された理想のインタプリタを定義します。

TODO

## 2.5 純粋で汚い関数たち

C++ やその他の手続き型言語における関数呼び出しは、数学における関数呼び出しとは意味が異なります。数学的な関数は、ただ値から値をマッピングするものです。

TODO

## 2.6 型の例

一度型が集合であることに気づくと、かなり変わった型について考えることができるようになります。例えば、空集合に対応する型はなんでしょうか？空集合は、C++ における void 型ではなく、Haskell における `Void` 型に対応します。

TODO

# まとめ